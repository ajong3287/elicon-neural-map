# STEP05.7 완결 작업 로그

**날짜**: 2025-12-23
**작업자**: 클로드 (Claude Code)
**작업 범위**: STEP05.7 click to focus

---

## 작업 요약

### 완료된 PR

| PR | 제목 | 파일 수 | 상태 | URL |
|---|------|--------|------|-----|
| #18 | STEP05.7 — click to focus | 1 | OPEN | https://github.com/ajong3287/elicon-neural-map/pull/18 |

---

## PR #18 (STEP05.7)

### 목적
- Dashboard Hub/Isolated 항목 클릭 시 해당 노드로 포커스
- 포커스된 노드 강조 + 나머지 노드 dim
- Focus-only 모드 (1-hop 이웃만 표시)

### 변경 파일
```
1. src/app/map/MapClient.tsx (수정)  - Focus 로직 + Dashboard 클릭 + Focus Controls + 비주얼 스타일
```

### 커밋
```
ac14f5a0 feat: step05.7 click to focus (NEURALMAP-STEP05.7-v0.1)
```

---

## 주요 변경사항

### 1. Focus State (lines 132-134)

```typescript
// STEP05.7: Focus state
const [focusId, setFocusId] = useState<string | null>(null);
const [focusOnly, setFocusOnly] = useState<boolean>(false);
```

- **focusId**: 현재 포커스된 노드 ID (null이면 포커스 없음)
- **focusOnly**: 1-hop 이웃만 표시 여부

### 2. Focus Pipeline (lines 261-297)

**focusNodes useMemo** (lines 261-271):
```typescript
const focusNodes = useMemo(() => {
  if (!focusId) return highlightedNodes;
  return highlightedNodes.map((n: any) => {
    const isFocus = n.id === focusId;
    return {
      ...n,
      isFocus,
      dim: !isFocus,
    };
  });
}, [highlightedNodes, focusId]);
```

- focusId가 없으면 highlightedNodes 그대로 반환
- focusId가 있으면 각 노드에 isFocus, dim 속성 추가
- isFocus: 포커스된 노드 (true/false)
- dim: 포커스되지 않은 노드 (true/false)

**focusFiltered useMemo** (lines 272-297):
```typescript
const focusFiltered = useMemo(() => {
  if (!focusOnly || !focusId) return { nodes: focusNodes, edges: filtered.edges };

  const neighbor = new Set<string>();
  neighbor.add(focusId);

  for (const e of filtered.edges as any[]) {
    const a = (e.from ?? e.source ?? e.a) as string | undefined;
    const b = (e.to ?? e.target ?? e.b) as string | undefined;
    if (!a || !b) continue;
    if (a === focusId) neighbor.add(b);
    if (b === focusId) neighbor.add(a);
  }

  const nodes = (focusNodes as any[]).filter((n) => neighbor.has(n.id));
  const set = new Set(nodes.map((n) => n.id));
  const edges = (filtered.edges as any[]).filter((e) => {
    const a = (e.from ?? e.source ?? e.a) as string | undefined;
    const b = (e.to ?? e.target ?? e.b) as string | undefined;
    if (!a || !b) return false;
    return set.has(a) && set.has(b);
  });

  return { nodes, edges };
}, [focusOnly, focusId, focusNodes, filtered.edges]);
```

- focusOnly가 false이거나 focusId가 없으면 전체 노드 반환
- focusOnly가 true이면 1-hop 이웃만 필터링
- 알고리즘: 포커스 노드와 직접 연결된 노드만 유지 + 해당 엣지만 유지

### 3. Elements 업데이트 (lines 299-364)

```typescript
const elements = useMemo(() => {
  // ...
  // Use focusFiltered.nodes (already has all filters + focus + hub)
  const nodes = focusFiltered.nodes.map((n: any) => ({
    data: {
      id: n.id,
      label: n.label,
      ext: n.ext,
      degree: n.deg ?? 0,
      score: n.score ?? 0,
      path: n.path,
      parent: nodeToCluster.get(n.id),
      isHub: n.isHub,      // STEP05.6: Hub indicator
      isFocus: n.isFocus,  // STEP05.7: Focus indicator
      dim: n.dim,          // STEP05.7: Dim indicator
    },
  }));

  // Use focusFiltered.edges (already filtered)
  const edges = focusFiltered.edges.map((e: any, i: number) => {
    const source = (e.from ?? e.source ?? e.a) as string;
    const target = (e.to ?? e.target ?? e.b) as string;
    return {
      data: {
        id: `${source}__${target}__${i}`,
        source,
        target,
        type: e.type
      }
    };
  });
  // ...
}, [graph, focusFiltered, collapsedClusters]);
```

- focusFiltered.nodes/edges 사용 (기존: filtered 직접 사용)
- isHub, isFocus, dim 속성을 data에 포함

### 4. Dashboard UI 업데이트 (lines 842-952)

**Hub nodes 클릭 연동** (lines 886-916):
```typescript
{dashboard.hubs.map((h) => (
  <div
    key={h.id}
    onClick={() => setFocusId(h.id)}
    style={{
      display: "flex",
      justifyContent: "space-between",
      fontSize: 11,
      padding: "4px 6px",
      opacity: 0.9,
      cursor: "pointer",
      borderRadius: 4,
      background: focusId === h.id ? "rgba(251,191,36,0.2)" : "transparent",
    }}
    onMouseEnter={(e) => {
      e.currentTarget.style.background = "rgba(251,191,36,0.15)";
    }}
    onMouseLeave={(e) => {
      e.currentTarget.style.background = focusId === h.id ? "rgba(251,191,36,0.2)" : "transparent";
    }}
  >
    <span style={{ whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis" }}>{h.label}</span>
    <span style={{ opacity: 0.7, marginLeft: 6, flexShrink: 0 }}>({h.deg})</span>
  </div>
))}
```

- onClick: setFocusId(h.id)
- 현재 포커스 항목 배경색 하이라이트
- hover 시 배경색 변화

**Isolated nodes 클릭 연동** (lines 918-950):
```typescript
{dashboard.isolated.map((iso) => (
  <div
    key={iso.id}
    onClick={() => setFocusId(iso.id)}
    style={{
      fontSize: 11,
      padding: "4px 6px",
      opacity: 0.9,
      cursor: "pointer",
      borderRadius: 4,
      background: focusId === iso.id ? "rgba(239,68,68,0.2)" : "transparent",
      whiteSpace: "nowrap",
      overflow: "hidden",
      textOverflow: "ellipsis",
    }}
    onMouseEnter={(e) => {
      e.currentTarget.style.background = "rgba(239,68,68,0.15)";
    }}
    onMouseLeave={(e) => {
      e.currentTarget.style.background = focusId === iso.id ? "rgba(239,68,68,0.2)" : "transparent";
    }}
  >
    {iso.label}
  </div>
))}
```

- 동일한 클릭 연동 패턴 (빨간색 테마)

### 5. Focus Controls UI (lines 798-828)

```typescript
{/* STEP05.7: Focus Controls */}
<div style={{ display: "flex", flexWrap: "wrap", gap: 10, alignItems: "center", padding: "10px", background: "#0b0b0f", borderBottom: "1px solid #1f2937" }}>
  {focusId ? (
    <>
      <div style={{ display: "flex", gap: 6, alignItems: "center", padding: "6px 10px", background: "rgba(251,191,36,0.15)", borderRadius: 8, border: "1px solid rgba(251,191,36,0.3)" }}>
        <span style={{ fontSize: 12, fontWeight: 600, color: "#fbbf24" }}>Focus:</span>
        <span style={{ fontSize: 12, opacity: 0.9, maxWidth: 200, whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis" }}>
          {focusFiltered.nodes.find((n: any) => n.id === focusId)?.label ?? focusId}
        </span>
      </div>

      <button
        onClick={() => setFocusId(null)}
        style={{ padding: "6px 12px", borderRadius: 8, border: "1px solid #374151", background: "#0f172a", color: "#e5e7eb", cursor: "pointer", fontSize: 12 }}
      >
        Clear
      </button>

      <label style={{ display: "flex", gap: 6, alignItems: "center", fontSize: 12, opacity: 0.9 }}>
        <input
          type="checkbox"
          checked={focusOnly}
          onChange={(e) => setFocusOnly(e.target.checked)}
        />
        focus only (1-hop)
      </label>
    </>
  ) : (
    <div style={{ fontSize: 12, opacity: 0.6 }}>클릭하여 노드 포커스</div>
  )}
</div>
```

**구성**:
- **Focus 표시**: 현재 포커스된 노드 이름 (노란색 배경)
- **Clear 버튼**: 포커스 해제 (setFocusId(null))
- **Focus-only 토글**: 1-hop 이웃만 표시
- **초기 상태**: "클릭하여 노드 포커스" 안내 메시지

### 6. Visual Styles (lines 488-499)

**Hub node 스타일** (lines 481-486):
```typescript
.selector("node[isHub]")
.style({
  "border-width": 3,
  "border-color": "#fbbf24",
  "border-style": "solid"
})
```

**Focused node 스타일** (lines 488-494):
```typescript
.selector("node[isFocus]")
.style({
  "border-width": 4,
  "border-color": "#22c55e",
  "border-style": "solid",
  opacity: 1
})
```

- 초록 테두리 (4px, #22c55e)
- 불투명도 1 (dim 무시)

**Dimmed node 스타일** (lines 496-499):
```typescript
.selector("node[dim]")
.style({
  opacity: 0.25
})
```

- 투명도 0.25 (75% 투명)

---

## STEP05.6 포함 사항

이 PR은 main 기반이므로 STEP05.6 코드도 함께 포함되었습니다:

### 1. 유틸 함수 (lines 76-94)
- `getTopDir()` - 최상위 폴더 추출
- `getExt()` - 확장자 추출
- `toSortedTop()` - Top N 정렬 추출

### 2. Filter State (lines 126-130)
- `dirFilter` - 폴더 필터
- `extFilter` - 확장자 필터
- `hideIsolated` - 고립 노드 숨김
- `hubThreshold` - 허브 임계값 (기본 6)

### 3. Filter Pipeline (lines 161-252)
- `filterOptions` - 폴더/확장자 목록
- `degreeMap` - 노드별 degree 계산
- `filtered` - 통합 필터 파이프라인
- `highlightedNodes` - 허브 속성 추가

### 4. Dashboard Data (lines 366-407)
- 폴더/확장자 분포 Top 12
- 허브 노드 Top 12
- 고립 노드 Top 30

### 5. Filter Controls UI (lines 742-796)
- 폴더 드롭다운
- 확장자 드롭다운
- hide isolated 체크박스
- hub threshold 슬라이더

---

## 검증 완료 사항

- [x] pnpm build: Exit 0
- [x] 파일 수: 1개 (MapClient.tsx)
- [x] base: main
- [x] 외부 패키지 추가 없음 (useMemo + 표준 React)

---

## 기술적 세부사항

### Filter/Focus Pipeline 아키텍처

**6단계 파이프라인**:
```
graph.nodes/edges (원본 데이터)
  ↓
filterOptions (폴더/확장자 목록 계산)
  ↓
degreeMap (degree 계산)
  ↓
filtered (모든 필터 적용: search, folder, score, dir, ext, isolated, collapsed)
  ↓
highlightedNodes (isHub 속성 추가)
  ↓
focusNodes (isFocus, dim 속성 추가)
  ↓
focusFiltered (1-hop 이웃 필터링)
  ↓
elements (Cytoscape 형식 변환)
```

**시간 복잡도**:
- Degree 계산: O(N + E)
- Filter 적용: O(N)
- Hub 하이라이트: O(N)
- Focus 속성 추가: O(N)
- 1-hop 필터링: O(E + N)
- **총**: O(N + E)

**공간 복잡도**: O(N + E)

### 1-Hop 이웃 알고리즘

**알고리즘**:
1. focusOnly가 false이거나 focusId가 없으면 → 전체 노드 반환
2. focusOnly가 true이면:
   - neighbor Set 생성 (focusId 포함)
   - 모든 엣지 순회하여 focusId와 연결된 노드 추가
   - neighbor에 포함된 노드만 필터링
   - neighbor 간 엣지만 필터링

**코드**:
```typescript
const neighbor = new Set<string>();
neighbor.add(focusId);

for (const e of filtered.edges as any[]) {
  const a = (e.from ?? e.source ?? e.a) as string | undefined;
  const b = (e.to ?? e.target ?? e.b) as string | undefined;
  if (!a || !b) continue;
  if (a === focusId) neighbor.add(b);
  if (b === focusId) neighbor.add(a);
}

const nodes = (focusNodes as any[]).filter((n) => neighbor.has(n.id));
```

### UI 반응형 업데이트

**상태 변경 → 자동 재계산**:
```
focusId 변경
  ↓
focusNodes useMemo 재실행
  ↓
focusFiltered useMemo 재실행 (focusOnly도 체크)
  ↓
elements useMemo 재실행
  ↓
Cytoscape 렌더 업데이트
```

**성능 최적화**:
- useMemo 의존성 배열 정확히 지정
- 불필요한 재계산 방지
- 84 nodes, 3 edges → 즉시 계산 (< 1ms)

---

## 다음 단계

### STEP05.8 (예상)
- 노드 클릭 시 자동 포커스 옵션
- 포커스 히스토리 (뒤로/앞으로)
- 멀티 포커스 (여러 노드 동시 포커스)

---

**작업 완료 시각**: 2025-12-23 05:00
**최종 상태**: PR #18 생성 완료, dev 테스트 대기

