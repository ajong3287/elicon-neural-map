# STEP05.3 완결 작업 로그

**날짜**: 2025-12-23
**작업자**: 클로드 (Claude Code)
**작업 범위**: STEP05.3 force layout (client-side)

---

## 작업 요약

### 완료된 PR

| PR | 제목 | 파일 수 | 상태 | URL |
|---|------|--------|------|-----|
| #14 | STEP05.3 — force layout | 3 | OPEN | https://github.com/ajong3287/elicon-neural-map/pull/14 |

---

## PR #14 (STEP05.3)

### 목적
- graph.json의 x,y=0 문제를 클라이언트 레이아웃으로 해결
- 노드 겹침 제거 → 의존성 구조 가독성 향상

### 변경 파일
```
1. src/app/map/MapClient.tsx  - Force layout 로직 추가
2. scripts/scan_repo.mjs       - STEP05.2에서 복사
3. public/graph.json            - STEP05.2에서 복사 (84 nodes, 3 edges)
```

### 커밋
```
1e4ffdc9 feat: step05.3 force layout for readable map (NEURALMAP-STEP05.3-v0.1)
```

---

## 주요 변경사항

### 1. runForceLayout() 함수 추가

**위치**: MapClient.tsx 76-164줄

**알고리즘**:
```javascript
function runForceLayout(
  nodes: any[],
  edges: any[],
  opts?: { width, height, iterations, repulsion, spring, damping, centerPull }
) {
  // 1) 초기값: 원형 배치 (겹침 방지)
  // 2) 반복 (260회 기본):
  //    - 반발력 (노드-노드)
  //    - 스프링력 (엣지)
  //    - 중심 끌어당김
  //    - 적분 + 감쇠 + 경계 클램프
  return nodes; // x, y 좌표 업데이트됨
}
```

**파라미터 기본값**:
```javascript
width: 760
height: 520
iterations: 260 (220으로 실제 사용)
repulsion: 9000
spring: 0.012
damping: 0.86
centerPull: 0.002
```

### 2. State 및 Effect 추가

**State**:
```typescript
const [laidNodes, setLaidNodes] = useState<GNode[]>([]);
```

**Force Layout Effect** (206-215줄):
```typescript
useEffect(() => {
  if (!graph || graph.nodes.length === 0) return;
  const clone = graph.nodes.map(n => ({ ...n, x: n.x ?? 0, y: n.y ?? 0 }));
  const laid = runForceLayout(
    clone,
    graph.edges.map(e => ({ from: e.source, to: e.target })),
    { width: 760, height: 520, iterations: 220 }
  );
  setLaidNodes(laid as any);
}, [graph]);
```

### 3. 렌더링 변경

**이전**:
```typescript
const nodes = graph.nodes
  .filter(...)
  .map(n => ({ data: { id, label, ... } }));
```

**이후**:
```typescript
const sourceNodes = laidNodes.length > 0 ? laidNodes : graph.nodes;
const nodes = sourceNodes
  .filter(...)
  .map(n => ({
    data: {
      id, label, ...,
      x: (n as any).x,
      y: (n as any).y
    }
  }));
```

### 4. 타입 업데이트

**GNode 타입**:
```typescript
// 이전
type GNode = { id, label, ext, path, degree?, score? };

// 이후
type GNode = { id, label, ext, path, degree?, score?, x?, y? };
```

---

## 검증 완료 사항

- [x] pnpm build: Exit 0
- [x] 파일 수: 3개 (MapClient.tsx + scan_repo.mjs + graph.json)
- [x] base: main
- [x] Force layout 로직: 260회 반복, 4단계 계산

---

## 기술적 세부사항

### Force-Directed Layout 알고리즘

**4가지 힘의 조합**:

#### 1. 반발력 (Repulsion)
```javascript
// 모든 노드 쌍에 대해
for (let i = 0; i < nodes.length; i++) {
  for (let j = i + 1; j < nodes.length; j++) {
    const dx = nodes[i].x - nodes[j].x;
    const dy = nodes[i].y - nodes[j].y;
    const dist2 = dx * dx + dy * dy + 0.01;
    const f = repulsion / dist2; // 9000 / 거리²
    // 벡터 정규화 후 힘 적용
    const inv = 1 / Math.sqrt(dist2);
    const fx = dx * inv * f;
    const fy = dy * inv * f;
    vx[i] += fx; vy[i] += fy;
    vx[j] -= fx; vy[j] -= fy;
  }
}
```

#### 2. 스프링력 (Spring/Edge)
```javascript
// 엣지로 연결된 노드들만
for (const [a, b] of pairs) {
  const dx = nodes[b].x - nodes[a].x;
  const dy = nodes[b].y - nodes[a].y;
  const dist = Math.sqrt(dx * dx + dy * dy) + 0.01;
  const target = 90; // 목표 거리
  const k = spring * (dist - target); // 0.012 * (실제 - 목표)
  const fx = (dx / dist) * k;
  const fy = (dy / dist) * k;
  vx[a] += fx; vy[a] += fy;
  vx[b] -= fx; vy[b] -= fy;
}
```

#### 3. 중심 끌어당김 (Center Pull)
```javascript
// 화면 밖 이탈 방지
for (let i = 0; i < nodes.length; i++) {
  vx[i] += (cx - nodes[i].x) * centerPull; // 0.002
  vy[i] += (cy - nodes[i].y) * centerPull;
}
```

#### 4. 적분 + 감쇠 + 경계
```javascript
for (let i = 0; i < nodes.length; i++) {
  vx[i] *= damping; // 0.86
  vy[i] *= damping;

  nodes[i].x += vx[i];
  nodes[i].y += vy[i];

  // 화면 밖 튐 방지
  nodes[i].x = Math.max(30, Math.min(width - 30, nodes[i].x));
  nodes[i].y = Math.max(30, Math.min(height - 30, nodes[i].y));
}
```

### 초기 배치

**원형 퍼뜨리기**:
```javascript
for (let i = 0; i < nodes.length; i++) {
  const a = (i / Math.max(1, nodes.length)) * Math.PI * 2;
  nodes[i].x = cx + Math.cos(a) * (Math.min(width, height) * 0.32);
  nodes[i].y = cy + Math.sin(a) * (Math.min(width, height) * 0.32);
}
```

**효과**: 노드들이 완전히 겹치지 않고 원형으로 시작 → 반복 계산 수렴 빠름

---

## 성능 특성

**계산 복잡도**:
- 반발력: O(n²) per iteration (모든 노드 쌍)
- 스프링력: O(e) per iteration (엣지 수)
- 총: O(iterations × (n² + e))

**현재 규모**:
- 노드: 84개
- 엣지: 3개
- 반복: 220회
- 계산: 220 × (84² + 3) ≈ 1,550,000회

**성능 안전**:
- 초기 로딩 시 1회만 실행
- 84개 노드 정도는 즉시 완료 (< 100ms 예상)
- 수천 노드 시 최적화 필요 (Web Worker 등)

---

## 다음 단계

### STEP05.4 (예상)
- 웹 업로드 기능 (graph.json 또는 zip)
- /api/graph 엔드포인트
- 토큰 인증
- 업로드 후 즉시 /map 반영

---

**작업 완료 시각**: 2025-12-23 01:00
**최종 상태**: PR #14 생성 완료, dev 확인 대기
