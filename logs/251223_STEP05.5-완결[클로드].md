# STEP05.5 완결 작업 로그

**날짜**: 2025-12-23
**작업자**: 클로드 (Claude Code)
**작업 범위**: STEP05.5 dashboard distribution panels

---

## 작업 요약

### 완료된 PR

| PR | 제목 | 파일 수 | 상태 | URL |
|---|------|--------|------|-----|
| #16 | STEP05.5 — dashboard distribution | 1 | OPEN | https://github.com/ajong3287/elicon-neural-map/pull/16 |

---

## PR #16 (STEP05.5)

### 목적
- 그래프 분포/요약 대시보드 추가
- 폴더/확장자/허브/고립노드 즉시 확인
- 빈틈 찾기 속도 향상

### 변경 파일
```
1. src/app/map/MapClient.tsx (수정)  - 유틸 함수 3개 + 대시보드 로직 + UI 패널
```

### 커밋
```
f4682694 feat: step05.5 dashboard distribution panels (NEURALMAP-STEP05.5-v0.1)
```

---

## 주요 변경사항

### 1. 유틸 함수 추가 (line 76-94)

**getTopDir()**:
```typescript
function getTopDir(label: string) {
  const p = (label || "").replaceAll("\\", "/");
  if (!p.includes("/")) return ".";
  return p.split("/")[0] || ".";
}
```
- 파일 경로에서 최상위 폴더 추출
- 예: "src/app/map/page.tsx" → "src"

**getExt()**:
```typescript
function getExt(label: string) {
  const base = (label || "").split("/").pop() || "";
  const i = base.lastIndexOf(".");
  if (i <= 0) return "(noext)";
  return base.slice(i + 1).toLowerCase();
}
```
- 파일명에서 확장자 추출
- 예: "page.tsx" → "tsx"

**toSortedTop()**:
```typescript
function toSortedTop(map: Map<string, number>, topN: number) {
  const arr = Array.from(map.entries()).sort((a, b) => b[1] - a[1]);
  const top = arr.slice(0, topN);
  const rest = arr.slice(topN).reduce((s, [, v]) => s + v, 0);
  return { top, rest };
}
```
- Map을 정렬하여 Top N 추출
- 나머지 합계도 계산

### 2. 대시보드 계산 로직 (line 220-281)

**dashNodes / dashEdges**:
```typescript
const dashNodes = useMemo(() => {
  const g = (typeof graph !== "undefined" && graph && Array.isArray(graph.nodes)) ? graph.nodes : null;
  return (g ?? []) as any[];
}, [graph]);

const dashEdges = useMemo(() => {
  const g = (typeof graph !== "undefined" && graph && Array.isArray(graph.edges)) ? graph.edges : null;
  return (g ?? []) as any[];
}, [graph]);
```
- graph.nodes, graph.edges를 useMemo로 캐싱

**dashboard 계산**:
```typescript
const dashboard = useMemo(() => {
  const nodes = dashNodes || [];
  const edges = dashEdges || [];

  const extMap = new Map<string, number>();
  const dirMap = new Map<string, number>();

  // degree 계산
  const degree = new Map<string, number>();
  for (const n of nodes) degree.set(n.id, 0);

  for (const e of edges) {
    const a = (e.from ?? e.source ?? e.a) as string | undefined;
    const b = (e.to ?? e.target ?? e.b) as string | undefined;
    if (!a || !b) continue;
    degree.set(a, (degree.get(a) ?? 0) + 1);
    degree.set(b, (degree.get(b) ?? 0) + 1);
  }

  // 폴더/확장자 분포 계산
  for (const n of nodes) {
    const label = (n.label ?? "") as string;
    const ext = getExt(label);
    const dir = getTopDir(label);
    extMap.set(ext, (extMap.get(ext) ?? 0) + 1);
    dirMap.set(dir, (dirMap.get(dir) ?? 0) + 1);
  }

  // 허브 노드 (Top 12)
  const hubs = nodes
    .map((n) => ({ id: n.id, label: n.label ?? n.id, deg: degree.get(n.id) ?? 0 }))
    .sort((a, b) => b.deg - a.deg)
    .slice(0, 12);

  // 고립 노드 (Top 30)
  const isolated = nodes
    .filter((n) => (degree.get(n.id) ?? 0) === 0)
    .map((n) => ({ id: n.id, label: n.label ?? n.id }))
    .slice(0, 30);

  const extTop = toSortedTop(extMap, 12);
  const dirTop = toSortedTop(dirMap, 12);

  return {
    nodesCount: nodes.length,
    edgesCount: edges.length,
    extTop,
    dirTop,
    hubs,
    isolatedCount: (nodes.filter((n) => (degree.get(n.id) ?? 0) === 0)).length,
    isolated,
  };
}, [dashNodes, dashEdges]);
```

**계산 항목**:
- **노드/엣지 개수**: nodesCount, edgesCount
- **폴더 분포**: dirTop (Top 12 + 나머지 합계)
- **확장자 분포**: extTop (Top 12 + 나머지 합계)
- **허브 노드**: hubs (연결 많은 순 Top 12)
- **고립 노드**: isolated (연결 0인 노드 Top 30)

### 3. Dashboard UI (line 716-787)

**위치**: 우측 패널 상단 (Inspector 위)

**구조**:
- 헤더: "Dashboard" + 노드/엣지 개수
- 2×2 그리드:
  - Top folders (상위 폴더 분포)
  - Top extensions (확장자 분포)
  - Hub nodes (허브 노드 목록)
  - Isolated (고립 노드 목록)

**UI 코드 예시**:
```tsx
<div style={{ display: "grid", gap: 10, padding: 10, border: "1px solid rgba(0,0,0,0.08)", borderRadius: 12 }}>
  <div style={{ display: "flex", justifyContent: "space-between", alignItems: "baseline" }}>
    <div style={{ fontWeight: 700 }}>Dashboard</div>
    <div style={{ opacity: 0.7, fontSize: 12 }}>
      nodes {dashboard.nodesCount} · edges {dashboard.edgesCount}
    </div>
  </div>

  <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 10 }}>
    {/* Top folders */}
    <div style={{ padding: 10, border: "1px solid rgba(0,0,0,0.08)", borderRadius: 12 }}>
      <div style={{ fontWeight: 700, marginBottom: 6 }}>Top folders</div>
      {dashboard.dirTop.top.map(([k, v]) => (
        <div key={k} style={{ display: "flex", justifyContent: "space-between", fontSize: 12, padding: "2px 0" }}>
          <span style={{ opacity: 0.9 }}>{k}</span>
          <span style={{ opacity: 0.7 }}>{v}</span>
        </div>
      ))}
      {/* others 합계 */}
    </div>

    {/* Top extensions, Hub nodes, Isolated 동일 패턴 */}
  </div>
</div>
```

---

## 검증 완료 사항

- [x] pnpm build: Exit 0
- [x] 파일 수: 1개 (MapClient.tsx)
- [x] base: main
- [x] 외부 패키지 추가 없음 (useMemo + 순수 JS)

---

## 기술적 세부사항

### 분포 계산 알고리즘

**시간 복잡도**:
- 노드 순회: O(N)
- 엣지 순회 (degree 계산): O(E)
- 정렬: O(N log N)
- **총**: O(N log N + E)

**공간 복잡도**: O(N + E)

**성능**:
- 84 nodes, 3 edges → 즉시 계산 (< 1ms)
- 수백 노드 → useMemo 캐싱으로 효율적

### degree 계산 방식

```typescript
const degree = new Map<string, number>();
for (const n of nodes) degree.set(n.id, 0);

for (const e of edges) {
  const a = (e.from ?? e.source ?? e.a) as string | undefined;
  const b = (e.to ?? e.target ?? e.b) as string | undefined;
  if (!a || !b) continue;
  degree.set(a, (degree.get(a) ?? 0) + 1);
  degree.set(b, (degree.get(b) ?? 0) + 1);
}
```

- 무향 그래프 가정 (source, target 모두 degree +1)
- 엣지 속성 다중 지원 (from/source/a, to/target/b)

### 분포 집계 방식

**폴더 분포**:
- getTopDir()로 최상위 폴더 추출
- Map으로 카운팅 → Top 12 추출
- 나머지 합계 계산 (others)

**확장자 분포**:
- getExt()로 확장자 추출
- 확장자 없으면 "(noext)"
- Map으로 카운팅 → Top 12 추출

### 허브/고립 노드 선정

**허브 노드**:
- degree 기준 내림차순 정렬
- Top 12 선정

**고립 노드**:
- degree === 0 필터링
- Top 30 선정 (UX 고려)
- 전체 개수는 isolatedCount로 표시

---

## 다음 단계

### STEP05.6 (예상)
- 폴더/확장자 필터 클릭 기능
- 고립 노드 숨김/표시 토글
- 허브 노드 하이라이트

---

**작업 완료 시각**: 2025-12-23 03:00
**최종 상태**: PR #16 생성 완료, dev 테스트 대기
